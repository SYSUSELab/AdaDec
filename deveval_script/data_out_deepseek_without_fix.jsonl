{"namespace": "benedict.utils.type_util.is_json_serializable", "result": "def is_json_serializable(val):\n    \"\"\"\n    Check if the input value is JSON serializable. It checks if the input value is of the JSON serializable types.\n    :param val: Any. The input value to be checked for JSON serializability.\n    :return: Bool. True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False"}
{"namespace": "feedparser.urls.convert_to_idn", "result": "def convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation. It checks if the host can be encoded in ASCII. If not, it converts the host to IDN form.\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    \"\"\"\n    import idna\n    from urllib.parse import urlparse\n    parsed_url = urlparse(url)\n    domain = parsed_url.hostname\n    try:\n        domain = idna.encode(domain).decode('utf-8')\n    except idna.core.IDNAError:\n        pass\n    return '{}://{}'.format(parsed_url.scheme, domain)"}
{"namespace": "mistune.toc.add_toc_hook", "result": "def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):\n    \"\"\"\n    This function adds a hook to save table of contents (TOC) items into the state.env. It is usually helpful for doc generator.\n    :param md: Markdown instance. The instance of the Markdown class.\n    :param min_level: Integer. The minimum heading level to include in the TOC.\n    :param max_level: Integer. The maximum heading level to include in the TOC.\n    :param heading_id: Function. A function to generate heading_id.\n    :return: No return values.\n    \"\"\"\n    # Your code here"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "result": "def is_json_serializable(val):\n    \"\"\"\n    Check if the input value is JSON serializable. It checks if the input value is of the JSON serializable types.\n    :param val: Any. The input value to be checked for JSON serializability.\n    :return: Bool. True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False"}
{"namespace": "feedparser.urls.convert_to_idn", "result": "def convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation. It checks if the host can be encoded in ASCII. If not, it converts the host to IDN form.\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    \"\"\"\n    import idna\n    from urllib.parse import urlparse\n    parsed_url = urlparse(url)\n    domain = parsed_url.hostname\n    try:\n        domain = idna.encode(domain).decode('utf-8')\n    except idna.core.IDNAError:\n        pass\n    return '{}://{}'.format(parsed_url.scheme, domain)"}
{"namespace": "mistune.toc.add_toc_hook", "result": "def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):\n    \"\"\"\n    This function adds a hook to save table of contents (TOC) items into the state.env. It is usually helpful for doc generator.\n    :param md: Markdown instance. The instance of the Markdown class.\n    :param min_level: Integer. The minimum heading level to include in the TOC.\n    :param max_level: Integer. The maximum heading level to include in the TOC.\n    :param heading_id: Function. A function to generate heading_id.\n    :return: No return values.\n    \"\"\"\n    # Your code here"}
{"namespace": "mistune.plugins.table.table_in_quote", "result": "def table_in_quote(md):\n    \"\"\"\n    This function enables the table plugin in block quotes by inserting rules for table and nptable before the paragraph in the block quote rules.\n    :param md: Markdown. The Markdown instance.\n    :return: No return values.\n    \"\"\"\n    # Insert rules for table and nptable before the paragraph in the block quote rules.\n    md.parser.blockprocessors.register(\n        'table',\n        '<table>\\n<tr>\\n<th>Column 1</th>\\n<th>Column 2</th>\\n</tr>\\n<tr>\\n<td>Cell 1</td>\\n<td>Cell 2</td>\\n</tr>\\n</table>',\n        '</table>',\n        '<p>\\n'\n    )\n    md.parser.blockprocessors.register(\n        'nptable',\n        '<table>\\n<tr>\\n<th>Column 1</th>\\n<th>Column 2</th>\\n</tr>\\n<tr>\\n<td>Cell 1</td>\\n<td>Cell 2</td>\\n</tr>\\n</table>',\n        '</table>',\n        '<p>\\n'\n    )"}
{"namespace": "benedict.utils.type_util.is_json_serializable", "result": "def is_json_serializable(val):\n    \"\"\"\n    Check if the input value is JSON serializable. It checks if the input value is of the JSON serializable types.\n    :param val: Any. The input value to be checked for JSON serializability.\n    :return: Bool. True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    try:\n        json.dumps(val)\n        return True\n    except (TypeError, OverflowError):\n        return False"}
